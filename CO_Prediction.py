# -*- coding: utf-8 -*-
"""DL_CO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ss37B2ijGRU9CDOBP0E0uNmNfXDVnhkn
"""

# ============================
# DNN Model
# ============================

import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import KFold
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

np.random.seed(42)
tf.random.set_seed(42)

# Dataset
data = pd.read_excel("Data-CO.xlsx")
categorical_columns = ["AT", "ST", "CT"]

X = data.drop(columns=["CO"])
y = data["CO"]

numeric_columns = [col for col in X.columns if col not in categorical_columns]
scaler = MinMaxScaler()
X[numeric_columns] = scaler.fit_transform(X[numeric_columns])

# Bootstrap CI
def bootstrap_ci(values, alpha=95, n_bootstrap=2000):
    means = []
    n = len(values)
    for _ in range(n_bootstrap):
        sample = np.random.choice(values, n, replace=True)
        means.append(np.mean(sample))
    lower = np.percentile(means, (100 - alpha) / 2)
    upper = np.percentile(means, 100 - (100 - alpha) / 2)
    return (lower, upper)

# DNN model
def build_neural_network(input_dim):
    model = Sequential()
    model.add(Dense(64, input_dim=input_dim, activation='relu'))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(1, activation='linear'))
    model.compile(optimizer="adam", loss="mse")
    return model


def run_deep_learning_models(X, y):

    nn_model = build_neural_network(X.shape[1])
    kf = KFold(n_splits=10, shuffle=True, random_state=42)

    y_true_nn = []
    y_pred_nn = []

    fold_r2 = []
    fold_rmse = []
    fold_mae = []
    fold_mape = []

    # ---- FOLD LOOP ----
    for train_idx, test_idx in kf.split(X):

        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]

        nn_model.fit(X_train, y_train, epochs=50, batch_size=8, verbose=0)
        preds = nn_model.predict(X_test).flatten()

        y_true_nn.extend(y_test)
        y_pred_nn.extend(preds)

        fold_r2.append(float(r2_score(y_test, preds)))
        rmse = float(np.sqrt(mean_squared_error(y_test, preds)))
        mae = float(mean_absolute_error(y_test, preds))

        non_zero = y_test != 0
        mape = float(np.mean(np.abs((y_test[non_zero] - preds[non_zero]) / y_test[non_zero])) * 100)

        fold_rmse.append(rmse)
        fold_mae.append(mae)
        fold_mape.append(mape)

    r2_mean_folds = np.mean(fold_r2)
    rmse_avg = np.mean(fold_rmse)
    mae_avg = np.mean(fold_mae)
    mape_avg = np.mean(fold_mape)

    r2_std = np.std(fold_r2)
    rmse_std = np.std(fold_rmse)
    mae_std = np.std(fold_mae)
    mape_std = np.std(fold_mape)

    # ---- 95% CI ----
    r2_ci = bootstrap_ci(fold_r2)
    rmse_ci = bootstrap_ci(fold_rmse)
    mae_ci = bootstrap_ci(fold_mae)
    mape_ci = bootstrap_ci(fold_mape)

    # ---- PRINT ----
    print("\n===== DNN MODEL ‚Äì 10 Fold Results =====")
    print(f"R¬≤: mean={r2_mean_folds:.4f}, std={r2_std:.4f}, 95%CI=({round(r2_ci[0],1)}, {round(r2_ci[1],1)})")
    print("RMSE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(rmse_avg, rmse_std, rmse_ci[0], rmse_ci[1]))
    print("MAE : mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(mae_avg, mae_std, mae_ci[0], mae_ci[1]))
    print("MAPE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(mape_avg, mape_std, mape_ci[0], mape_ci[1]))

    # ---- FOLD Printed ----
    print("\n--- Fold-by-Fold Results (3 decimals) ---")
    print("R2 per fold  :", [round(v, 3) for v in fold_r2])
    print("RMSE per fold:", [round(v, 3) for v in fold_rmse])
    print("MAE per fold :", [round(v, 3) for v in fold_mae])
    print("MAPE per fold:", [round(v, 3) for v in fold_mape])

    # ---- EXCEL OUTPUT ----
    results_df = pd.DataFrame({
        "Metric": ["R2_mean", "R2_std", "R2_CI_low", "R2_CI_high",
                   "RMSE_mean", "RMSE_std", "RMSE_CI_low", "RMSE_CI_high",
                   "MAE_mean", "MAE_std", "MAE_CI_low", "MAE_CI_high",
                   "MAPE_mean", "MAPE_std", "MAPE_CI_low", "MAPE_CI_high"],
        "Value": [
            r2_mean_folds, r2_std, r2_ci[0], r2_ci[1],
            rmse_avg, rmse_std, rmse_ci[0], rmse_ci[1],
            mae_avg, mae_std, mae_ci[0], mae_ci[1],
            mape_avg, mape_std, mape_ci[0], mape_ci[1]
        ]
    })

    folds_df = pd.DataFrame({
        "Fold": list(range(1, 11)),
        "R2": fold_r2,
        "RMSE": fold_rmse,
        "MAE": fold_mae,
        "MAPE": fold_mape
    })

    with pd.ExcelWriter("DNN_Results.xlsx") as writer:
        results_df.to_excel(writer, sheet_name="Summary", index=False)
        folds_df.to_excel(writer, sheet_name="Fold_Details", index=False)

    print("\nüìÅ Excel dosyasƒ± olu≈üturuldu: DNN_Results.xlsx")

    return {
        "r2_mean": r2_mean_folds,
        "fold_r2": fold_r2
    }


results_dnn = run_deep_learning_models(X, y)

##RNN
import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import KFold
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, SimpleRNN

np.random.seed(42)
tf.random.set_seed(42)

data = pd.read_excel("Data-CO.xlsx")
categorical_columns = ["AT", "ST", "CT"]

X = data.drop(columns=["CO"])
y = data["CO"]

numeric_columns = [col for col in X.columns if col not in categorical_columns]
scaler = MinMaxScaler()
X[numeric_columns] = scaler.fit_transform(X[numeric_columns])

# ---------------------------
# RNN Model
# ---------------------------
def build_rnn(input_dim):
    model = Sequential()
    model.add(SimpleRNN(64, input_shape=(1, input_dim), activation='relu'))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(1, activation='linear'))
    model.compile(optimizer='adam', loss='mse')
    return model

def reshape_for_rnn(X):
    return np.array(X).reshape(X.shape[0], 1, X.shape[1])

# ---------------------------
# Bootstrap CI
# ---------------------------
def bootstrap_ci(values, alpha=95, n_bootstrap=2000):
    means = []
    n = len(values)
    for _ in range(n_bootstrap):
        sample = np.random.choice(values, n, replace=True)
        means.append(np.mean(sample))
    lower = np.percentile(means, (100 - alpha) / 2)
    upper = np.percentile(means, 100 - (100 - alpha) / 2)
    return (lower, upper)

# ---------------------------
# 10-fold RNN Evaluation
# ---------------------------
def run_rnn_models(X, y):

    rnn_model = build_rnn(X.shape[1])
    kf = KFold(n_splits=10, shuffle=True, random_state=42)

    fold_r2 = []
    fold_rmse = []
    fold_mae = []
    fold_mape = []

    # ---- FOLD LOOP ----
    for train_idx, test_idx in kf.split(X):

        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]

        X_train_rnn = reshape_for_rnn(X_train)
        X_test_rnn = reshape_for_rnn(X_test)

        rnn_model.fit(X_train_rnn, y_train, epochs=50, batch_size=8, verbose=0)
        preds = rnn_model.predict(X_test_rnn).flatten()

        # ---- METRƒ∞KLER ----
        fold_r2.append(float(r2_score(y_test, preds)))
        rmse = float(np.sqrt(mean_squared_error(y_test, preds)))
        mae = float(mean_absolute_error(y_test, preds))

        non_zero = y_test != 0
        mape = float(np.mean(np.abs((y_test[non_zero] - preds[non_zero]) / y_test[non_zero])) * 100)

        fold_rmse.append(rmse)
        fold_mae.append(mae)
        fold_mape.append(mape)

    r2_mean = np.mean(fold_r2)
    rmse_mean = np.mean(fold_rmse)
    mae_mean = np.mean(fold_mae)
    mape_mean = np.mean(fold_mape)

    # ---- STD ----
    r2_std = np.std(fold_r2)
    rmse_std = np.std(fold_rmse)
    mae_std = np.std(fold_mae)
    mape_std = np.std(fold_mape)

    # ---- 95% CI ----
    r2_ci = bootstrap_ci(fold_r2)
    rmse_ci = bootstrap_ci(fold_rmse)
    mae_ci = bootstrap_ci(fold_mae)
    mape_ci = bootstrap_ci(fold_mape)

    # ---- PRINT ----
    print("\n===== RNN MODEL ‚Äì 10 Fold Results =====")
    print(f"R¬≤: mean={r2_mean:.4f}, std={r2_std:.4f}, 95%CI=({round(r2_ci[0],1)}, {round(r2_ci[1],1)})")
    print("RMSE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1]))
    print("MAE : mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(mae_mean, mae_std, mae_ci[0], mae_ci[1]))
    print("MAPE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(mape_mean, mape_std, mape_ci[0], mape_ci[1]))

    # ---- FOLD Printed ----
    print("\n--- Fold-by-Fold Results (3 decimals) ---")
    print("R2 per fold  :", [round(v, 3) for v in fold_r2])
    print("RMSE per fold:", [round(v, 3) for v in fold_rmse])
    print("MAE per fold :", [round(v, 3) for v in fold_mae])
    print("MAPE per fold:", [round(v, 3) for v in fold_mape])

    # ---- EXCEL OUTPUT ----
    results_df = pd.DataFrame({
        "Metric": ["R2_mean", "R2_std", "R2_CI_low", "R2_CI_high",
                   "RMSE_mean", "RMSE_std", "RMSE_CI_low", "RMSE_CI_high",
                   "MAE_mean", "MAE_std", "MAE_CI_low", "MAE_CI_high",
                   "MAPE_mean", "MAPE_std", "MAPE_CI_low", "MAPE_CI_high"],
        "Value": [
            r2_mean, r2_std, r2_ci[0], r2_ci[1],
            rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1],
            mae_mean, mae_std, mae_ci[0], mae_ci[1],
            mape_mean, mape_std, mape_ci[0], mape_ci[1]
        ]
    })

    folds_df = pd.DataFrame({
        "Fold": list(range(1, 11)),
        "R2": fold_r2,
        "RMSE": fold_rmse,
        "MAE": fold_mae,
        "MAPE": fold_mape
    })

    with pd.ExcelWriter("RNN_Results.xlsx") as writer:
        results_df.to_excel(writer, sheet_name="Summary", index=False)
        folds_df.to_excel(writer, sheet_name="Fold_Details", index=False)

    print("\nüìÅ Excel dosyasƒ± olu≈üturuldu: RNN_Results.xlsx")

    return {
        "r2_mean": r2_mean,
        "fold_r2": fold_r2
    }

results_rnn = run_rnn_models(X, y)

# ============================
# PURE CNN MODEL
# ============================

import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import KFold
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv1D, Flatten, Dense

np.random.seed(42)
tf.random.set_seed(42)

data = pd.read_excel("Data-CO.xlsx")
categorical_columns = ["AT", "ST", "CT"]

X = data.drop(columns=["CO"])
y = data["CO"]

numeric_columns = [col for col in X.columns if col not in categorical_columns]
scaler = MinMaxScaler()
X[numeric_columns] = scaler.fit_transform(X[numeric_columns])

# ============================
# Bootstrap CI
# ============================
def bootstrap_ci(values, alpha=95, n_bootstrap=2000):
    means = []
    n = len(values)
    for _ in range(n_bootstrap):
        sample = np.random.choice(values, n, replace=True)
        means.append(np.mean(sample))
    lower = np.percentile(means, (100 - alpha) / 2)
    upper = np.percentile(means, 100 - (100 - alpha) / 2)
    return (lower, upper)

# ============================
# Pure CNN Model
# ============================
def build_pure_cnn(input_dim):
    model = Sequential()
    model.add(Conv1D(filters=64, kernel_size=3, activation='relu', padding='same',
                     input_shape=(1, input_dim)))
    model.add(Conv1D(filters=128, kernel_size=3, activation='relu', padding='same'))
    model.add(Flatten())
    model.add(Dense(1, activation='linear'))
    model.compile(optimizer='adam', loss='mse')
    return model

def reshape_for_cnn(X):
    return np.array(X).reshape(X.shape[0], 1, X.shape[1])

# ============================
# 10-Fold CV
# ============================
def run_pure_cnn(X, y):

    cnn_model = build_pure_cnn(X.shape[1])
    kf = KFold(n_splits=10, shuffle=True, random_state=42)

    fold_r2 = []
    fold_rmse = []
    fold_mae = []
    fold_mape = []

    # ---- FOLD LOOP ----
    for train_idx, test_idx in kf.split(X):

        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]

        # CNN reshape
        X_train_cnn = reshape_for_cnn(X_train)
        X_test_cnn = reshape_for_cnn(X_test)

        cnn_model.fit(X_train_cnn, y_train, epochs=50, batch_size=8, verbose=0)

        preds = cnn_model.predict(X_test_cnn).flatten()

        fold_r2.append(float(r2_score(y_test, preds)))

        rmse = float(np.sqrt(mean_squared_error(y_test, preds)))
        mae = float(mean_absolute_error(y_test, preds))

        non_zero = y_test != 0
        mape = float(np.mean(np.abs((y_test[non_zero] - preds[non_zero]) /
                                    y_test[non_zero])) * 100)

        fold_rmse.append(rmse)
        fold_mae.append(mae)
        fold_mape.append(mape)

    r2_mean = np.mean(fold_r2)
    rmse_mean = np.mean(fold_rmse)
    mae_mean = np.mean(fold_mae)
    mape_mean = np.mean(fold_mape)

    # ---- STD ----
    r2_std = np.std(fold_r2)
    rmse_std = np.std(fold_rmse)
    mae_std = np.std(fold_mae)
    mape_std = np.std(fold_mape)

    # ---- 95% CI ----
    r2_ci = bootstrap_ci(fold_r2)
    rmse_ci = bootstrap_ci(fold_rmse)
    mae_ci = bootstrap_ci(fold_mae)
    mape_ci = bootstrap_ci(fold_mape)

    print("\n===== PURE CNN MODEL ‚Äì 10 Fold Results =====")
    print(f"R¬≤: mean={r2_mean:.4f}, std={r2_std:.4f}, 95%CI=({round(r2_ci[0],1)}, {round(r2_ci[1],1)})")
    print("RMSE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})"
          .format(rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1]))
    print("MAE : mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})"
          .format(mae_mean, mae_std, mae_ci[0], mae_ci[1]))
    print("MAPE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})"
          .format(mape_mean, mape_std, mape_ci[0], mape_ci[1]))

    print("\n--- Fold-by-Fold Results (3 decimals) ---")
    print("R2 per fold  :", [round(v, 3) for v in fold_r2])
    print("RMSE per fold:", [round(v, 3) for v in fold_rmse])
    print("MAE per fold :", [round(v, 3) for v in fold_mae])
    print("MAPE per fold:", [round(v, 3) for v in fold_mape])

    # ============================
    # Excel Export
    # ============================
    results_df = pd.DataFrame({
        "Metric": ["R2_mean", "R2_std", "R2_CI_low", "R2_CI_high",
                   "RMSE_mean", "RMSE_std", "RMSE_CI_low", "RMSE_CI_high",
                   "MAE_mean", "MAE_std", "MAE_CI_low", "MAE_CI_high",
                   "MAPE_mean", "MAPE_std", "MAPE_CI_low", "MAPE_CI_high"],
        "Value": [
            r2_mean, r2_std, r2_ci[0], r2_ci[1],
            rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1],
            mae_mean, mae_std, mae_ci[0], mae_ci[1],
            mape_mean, mape_std, mape_ci[0], mape_ci[1]
        ]
    })

    folds_df = pd.DataFrame({
        "Fold": list(range(1, 11)),
        "R2": fold_r2,
        "RMSE": fold_rmse,
        "MAE": fold_mae,
        "MAPE": fold_mape
    })

    with pd.ExcelWriter("PURE_CNN_Results.xlsx") as writer:
        results_df.to_excel(writer, sheet_name="Summary", index=False)
        folds_df.to_excel(writer, sheet_name="Fold_Details", index=False)

    print("\nüìÅ Excel dosyasƒ± olu≈üturuldu: PURE_CNN_Results.xlsx")

    return {
        "r2_mean": r2_mean,
        "fold_r2": fold_r2
    }

# √áalƒ±≈ütƒ±r
results_pure_cnn = run_pure_cnn(X, y)

# ============================
# LSTM MODEL
# ============================

import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import KFold
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM

# Seed
np.random.seed(42)
tf.random.set_seed(42)

# Dataset
data = pd.read_excel("Data-CO.xlsx")
categorical_columns = ["AT", "ST", "CT"]

X = data.drop(columns=["CO"])
y = data["CO"]

numeric_columns = [col for col in X.columns if col not in categorical_columns]
scaler = MinMaxScaler()
X[numeric_columns] = scaler.fit_transform(X[numeric_columns])

# ---------------------------
# Bootstrap CI
# ---------------------------
def bootstrap_ci(values, alpha=95, n_bootstrap=2000):
    means = []
    n = len(values)
    for _ in range(n_bootstrap):
        sample = np.random.choice(values, n, replace=True)
        means.append(np.mean(sample))
    lower = np.percentile(means, (100 - alpha) / 2)
    upper = np.percentile(means, 100 - (100 - alpha) / 2)
    return (lower, upper)

# ---------------------------
# LSTM model
# ---------------------------
def build_lstm(input_dim):
    model = Sequential()
    model.add(LSTM(64, input_shape=(1, input_dim), activation='tanh'))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(1, activation='linear'))
    model.compile(optimizer='adam', loss='mse')
    return model

def reshape_for_lstm(X):
    return np.array(X).reshape(X.shape[0], 1, X.shape[1])

# ---------------------------
# 10-Fold LSTM Evaluation
# ---------------------------
def run_lstm_models(X, y):

    lstm_model = build_lstm(X.shape[1])
    kf = KFold(n_splits=10, shuffle=True, random_state=42)

    fold_r2 = []
    fold_rmse = []
    fold_mae = []
    fold_mape = []

    # ---- FOLD LOOP ----
    for train_idx, test_idx in kf.split(X):

        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]

        X_train_lstm = reshape_for_lstm(X_train)
        X_test_lstm = reshape_for_lstm(X_test)

        lstm_model.fit(X_train_lstm, y_train, epochs=50, batch_size=8, verbose=0)

        preds = lstm_model.predict(X_test_lstm).flatten()

        # ---- METRICS ----
        fold_r2.append(float(r2_score(y_test, preds)))
        rmse = float(np.sqrt(mean_squared_error(y_test, preds)))
        mae = float(mean_absolute_error(y_test, preds))

        non_zero = y_test != 0
        mape = float(np.mean(np.abs((y_test[non_zero] - preds[non_zero]) / y_test[non_zero])) * 100)

        fold_rmse.append(rmse)
        fold_mae.append(mae)
        fold_mape.append(mape)

    # ---- Averages ----
    r2_mean = np.mean(fold_r2)
    rmse_mean = np.mean(fold_rmse)
    mae_mean = np.mean(fold_mae)
    mape_mean = np.mean(fold_mape)

    # ---- STD ----
    r2_std = np.std(fold_r2)
    rmse_std = np.std(fold_rmse)
    mae_std = np.std(fold_mae)
    mape_std = np.std(fold_mape)

    # ---- CI ----
    r2_ci = bootstrap_ci(fold_r2)
    rmse_ci = bootstrap_ci(fold_rmse)
    mae_ci = bootstrap_ci(fold_mae)
    mape_ci = bootstrap_ci(fold_mape)

    # ---- PRINT ----
    print("\n===== LSTM MODEL ‚Äì 10 Fold Results =====")
    print(f"R¬≤: mean={r2_mean:.4f}, std={r2_std:.4f}, 95%CI=({round(r2_ci[0],1)}, {round(r2_ci[1],1)})")
    print("RMSE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1]))
    print("MAE : mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(mae_mean, mae_std, mae_ci[0], mae_ci[1]))
    print("MAPE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})".format(mape_mean, mape_std, mape_ci[0], mape_ci[1]))

    print("\n--- Fold-by-Fold Results (3 decimals) ---")
    print("R2 per fold  :", [round(v, 3) for v in fold_r2])
    print("RMSE per fold:", [round(v, 3) for v in fold_rmse])
    print("MAE per fold :", [round(v, 3) for v in fold_mae])
    print("MAPE per fold:", [round(v, 3) for v in fold_mape])

    # ---- EXCEL OUTPUT ----
    results_df = pd.DataFrame({
        "Metric": ["R2_mean", "R2_std", "R2_CI_low", "R2_CI_high",
                   "RMSE_mean", "RMSE_std", "RMSE_CI_low", "RMSE_CI_high",
                   "MAE_mean", "MAE_std", "MAE_CI_low", "MAE_CI_high",
                   "MAPE_mean", "MAPE_std", "MAPE_CI_low", "MAPE_CI_high"],
        "Value": [
            r2_mean, r2_std, r2_ci[0], r2_ci[1],
            rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1],
            mae_mean, mae_std, mae_ci[0], mae_ci[1],
            mape_mean, mape_std, mape_ci[0], mape_ci[1]
        ]
    })

    folds_df = pd.DataFrame({
        "Fold": list(range(1, 11)),
        "R2": fold_r2,
        "RMSE": fold_rmse,
        "MAE": fold_mae,
        "MAPE": fold_mape
    })

    with pd.ExcelWriter("LSTM_Results.xlsx") as writer:
        results_df.to_excel(writer, sheet_name="Summary", index=False)
        folds_df.to_excel(writer, sheet_name="Fold_Details", index=False)

    print("\nüìÅ Excel dosyasƒ± olu≈üturuldu: LSTM_Results.xlsx")

    return {
        "r2_mean": r2_mean,
        "fold_r2": fold_r2
    }

results_lstm = run_lstm_models(X, y)

# ============================
# CNN-LSTM MODEL
# ============================

import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import KFold
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv1D, LSTM, Dense, Dropout

# Seed
np.random.seed(42)
tf.random.set_seed(42)

# Dataset
data = pd.read_excel("Data-CO.xlsx")
categorical_columns = ["AT", "ST", "CT"]

X = data.drop(columns=["CO"])
y = data["CO"]

numeric_columns = [col for col in X.columns if col not in categorical_columns]
scaler = MinMaxScaler()
X[numeric_columns] = scaler.fit_transform(X[numeric_columns])

# ============================
# Bootstrap CI
# ============================
def bootstrap_ci(values, alpha=95, n_bootstrap=2000):
    means = []
    n = len(values)
    for _ in range(n_bootstrap):
        sample = np.random.choice(values, n, replace=True)
        means.append(np.mean(sample))
    lower = np.percentile(means, (100 - alpha) / 2)
    upper = np.percentile(means, 100 - (100 - alpha) / 2)
    return (lower, upper)

# ============================
# CNN-LSTM Model
# ============================
def build_cnn_lstm(input_dim):
    model = Sequential()
    model.add(Conv1D(filters=64, kernel_size=1, activation='relu', padding='same',
                     input_shape=(1, input_dim)))
    model.add(Conv1D(filters=128, kernel_size=3, activation='relu', padding='same'))
    model.add(LSTM(128, activation='tanh', return_sequences=True))
    model.add(LSTM(64, activation='tanh', return_sequences=False))
    model.add(Dropout(0.2))
    model.add(Dense(32, activation='relu'))
    model.add(Dense(1, activation='linear'))
    model.compile(optimizer='adam', loss='mse')
    return model

def reshape_for_cnn_lstm(X):
    return np.array(X).reshape(X.shape[0], 1, X.shape[1])

# ============================
# 10-Fold CV
# ============================
def run_cnn_lstm_models(X, y):

    cnn_lstm_model = build_cnn_lstm(X.shape[1])
    kf = KFold(n_splits=10, shuffle=True, random_state=42)

    fold_r2 = []
    fold_rmse = []
    fold_mae = []
    fold_mape = []

    # ---- FOLD LOOP ----
    for train_idx, test_idx in kf.split(X):

        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]

        # reshape
        X_train_cl = reshape_for_cnn_lstm(X_train)
        X_test_cl = reshape_for_cnn_lstm(X_test)

        cnn_lstm_model.fit(X_train_cl, y_train, epochs=50, batch_size=8, verbose=0)
        preds = cnn_lstm_model.predict(X_test_cl).flatten()

        # ---- Metrics ----
        fold_r2.append(float(r2_score(y_test, preds)))
        rmse = float(np.sqrt(mean_squared_error(y_test, preds)))
        mae = float(mean_absolute_error(y_test, preds))

        non_zero = y_test != 0
        mape = float(np.mean(np.abs((y_test[non_zero] - preds[non_zero]) /
                                    y_test[non_zero])) * 100)

        fold_rmse.append(rmse)
        fold_mae.append(mae)
        fold_mape.append(mape)

    # ---- Averages ----
    r2_mean = np.mean(fold_r2)
    rmse_mean = np.mean(fold_rmse)
    mae_mean = np.mean(fold_mae)
    mape_mean = np.mean(fold_mape)

    # ---- STD ----
    r2_std = np.std(fold_r2)
    rmse_std = np.std(fold_rmse)
    mae_std = np.std(fold_mae)
    mape_std = np.std(fold_mape)

    # ---- CI ----
    r2_ci = bootstrap_ci(fold_r2)
    rmse_ci = bootstrap_ci(fold_rmse)
    mae_ci = bootstrap_ci(fold_mae)
    mape_ci = bootstrap_ci(fold_mape)

    print("\n===== CNN-LSTM MODEL ‚Äì 10 Fold Results =====")
    print(f"R¬≤: mean={r2_mean:.4f}, std={r2_std:.4f}, 95%CI=({round(r2_ci[0],1)}, {round(r2_ci[1],1)})")
    print("RMSE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})"
          .format(rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1]))
    print("MAE : mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})"
          .format(mae_mean, mae_std, mae_ci[0], mae_ci[1]))
    print("MAPE: mean={:.4f}, std={:.4f}, 95%CI=({:.1f}, {:.1f})"
          .format(mape_mean, mape_std, mape_ci[0], mape_ci[1]))

    print("\n--- Fold-by-Fold Results (3 decimals) ---")
    print("R2 per fold  :", [round(v, 3) for v in fold_r2])
    print("RMSE per fold:", [round(v, 3) for v in fold_rmse])
    print("MAE per fold :", [round(v, 3) for v in fold_mae])
    print("MAPE per fold:", [round(v, 3) for v in fold_mape])

    # ============================
    # Excel Export
    # ============================
    results_df = pd.DataFrame({
        "Metric": ["R2_mean", "R2_std", "R2_CI_low", "R2_CI_high",
                   "RMSE_mean", "RMSE_std", "RMSE_CI_low", "RMSE_CI_high",
                   "MAE_mean", "MAE_std", "MAE_CI_low", "MAE_CI_high",
                   "MAPE_mean", "MAPE_std", "MAPE_CI_low", "MAPE_CI_high"],
        "Value": [
            r2_mean, r2_std, r2_ci[0], r2_ci[1],
            rmse_mean, rmse_std, rmse_ci[0], rmse_ci[1],
            mae_mean, mae_std, mae_ci[0], mae_ci[1],
            mape_mean, mape_std, mape_ci[0], mape_ci[1]
        ]
    })

    folds_df = pd.DataFrame({
        "Fold": list(range(1, 11)),
        "R2": fold_r2,
        "RMSE": fold_rmse,
        "MAE": fold_mae,
        "MAPE": fold_mape
    })

    with pd.ExcelWriter("CNN_LSTM_Results.xlsx") as writer:
        results_df.to_excel(writer, sheet_name="Summary", index=False)
        folds_df.to_excel(writer, sheet_name="Fold_Details", index=False)

    print("\nüìÅ Excel dosyasƒ± olu≈üturuldu: CNN_LSTM_Results.xlsx")

    return {
        "r2_mean": r2_mean,
        "fold_r2": fold_r2
    }

results_cnn_lstm = run_cnn_lstm_models(X, y)

import pandas as pd
import matplotlib.pyplot as plt

color_map = {
    "DNN":      "#4C72B0",
    "RNN":      "#DD8452",
    "CNN":      "#55A868",
    "LSTM":     "#8172B3",
    "CNN-LSTM": "#C44E52"
}

models = ["DNN", "RNN", "CNN", "LSTM", "CNN-LSTM"]

model_files = {
    "DNN": "DNN_Results.xlsx",
    "RNN": "RNN_Results.xlsx",
    "CNN": "PURE_CNN_Results.xlsx",
    "LSTM": "LSTM_Results.xlsx",
    "CNN-LSTM": "CNN_LSTM_Results.xlsx"
}

r2_values = []
rmse_values = []

for model, fname in model_files.items():
    df = pd.read_excel(fname, sheet_name="Summary")
    r2_values.append(df.loc[df["Metric"]=="R2_mean","Value"].values[0])
    rmse_values.append(df.loc[df["Metric"]=="RMSE_mean","Value"].values[0])

fig, axes = plt.subplots(1, 2, figsize=(22, 8))

for ax in axes:
    ax.tick_params(axis='both', labelsize=18)

# ---------- R¬≤ ----------
axes[0].bar(models, r2_values, color=[color_map[m] for m in models])
axes[0].set_title("R¬≤", fontsize=28)
axes[0].set_ylim(0.90, 1.00)
axes[0].grid(axis='y', linestyle='--', alpha=0.5)

for i, v in enumerate(r2_values):
    axes[0].text(i, v + 0.002, f"{v:.4f}", ha='center', fontsize=20, fontweight='bold')

# ---------- RMSE ----------
axes[1].bar(models, rmse_values, color=[color_map[m] for m in models])
axes[1].set_title("RMSE", fontsize=28)
axes[1].set_ylim(0, 4)
axes[1].grid(axis='y', linestyle='--', alpha=0.5)

for i, v in enumerate(rmse_values):
    axes[1].text(i, v + 0.07, f"{v:.4f}", ha='center', fontsize=20, fontweight='bold')

plt.tight_layout()

plt.savefig("CO_R2_RMSE.png", dpi=400, bbox_inches='tight')

plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

color_map = {
    "DNN":      "#4C72B0",
    "RNN":      "#DD8452",
    "CNN":      "#55A868",
    "LSTM":     "#8172B3",
    "CNN-LSTM": "#C44E52"
}

model_files = {
    "DNN": "DNN_Results.xlsx",
    "RNN": "RNN_Results.xlsx",
    "CNN": "PURE_CNN_Results.xlsx",
    "LSTM": "LSTM_Results.xlsx",
    "CNN-LSTM": "CNN_LSTM_Results.xlsx"
}

models = list(model_files.keys())
folds = np.arange(1, 11)

mape_values = {}
mae_values = {}

for model, file in model_files.items():
    df = pd.read_excel(file, sheet_name="Fold_Details")
    mape_values[model] = df["MAPE"].tolist()
    mae_values[model] = df["MAE"].tolist()


fig, axes = plt.subplots(1, 2, figsize=(20, 8))

for ax in axes:
    ax.tick_params(axis='both', labelsize=16)

# ---- MAPE ----
for model in models:
    avg_mape = np.mean(mape_values[model])
    axes[0].plot(
        folds, mape_values[model],
        marker='o',
        markersize=8,
        linewidth=2.5,
        linestyle='--',
        label=f"{model} ({avg_mape:.2f})",
        color=color_map[model]
    )

axes[0].set_title("MAPE for 10-CV", fontsize=24)
axes[0].set_xlabel("Fold", fontsize=18)
axes[0].set_ylabel("MAPE", fontsize=18)
axes[0].grid(True, alpha=0.4)
axes[0].legend(fontsize=14)

# ---- MAE ----
for model in models:
    avg_mae = np.mean(mae_values[model])
    axes[1].plot(
        folds, mae_values[model],
        marker='s',
        markersize=8,
        linewidth=2.5,
        linestyle='-',
        label=f"{model} ({avg_mae:.3f})",
        color=color_map[model]
    )

axes[1].set_title("MAE for 10-CV", fontsize=24)
axes[1].set_xlabel("Fold", fontsize=18)
axes[1].set_ylabel("MAE", fontsize=18)
axes[1].grid(True, alpha=0.4)
axes[1].legend(fontsize=14)

plt.tight_layout()
plt.savefig("CO_MAPE_MAE.png", dpi=400, bbox_inches='tight')

plt.show()